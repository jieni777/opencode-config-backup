"""
FastAPI example project demonstrating modern Python best practices.

This example shows:
- FastAPI with async routes
- Pydantic models for validation
- Dependency injection
- Structured logging
- Configuration management
"""

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Optional, List
import structlog

from config import settings
from models import Item, ItemCreate, ItemUpdate
from database import get_db, AsyncSession

# Configure structured logging
structlog.configure(
    processors=[
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer(),
    ],
)

logger = structlog.get_logger(__name__)

# Create FastAPI app
app = FastAPI(
    title="Example API",
    description="A modern FastAPI example with best practices",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Routes
@app.get("/")
async def root() -> dict:
    """Root endpoint."""
    logger.info("Root endpoint called")
    return {"message": "Welcome to Example API", "version": "1.0.0"}


@app.get("/health")
async def health_check() -> dict:
    """Health check endpoint."""
    return {"status": "healthy", "version": "1.0.0"}


@app.post("/items", response_model=Item, status_code=status.HTTP_201_CREATED)
async def create_item(
    item: ItemCreate,
    db: AsyncSession = Depends(get_db),
) -> Item:
    """Create a new item."""
    logger.info("Creating item", name=item.name)

    # Create item (simplified - in real app, use ORM)
    new_item = Item(
        id=1,  # In real app, generated by DB
        name=item.name,
        description=item.description,
        price=item.price,
        status=item.status,
    )

    logger.info("Item created", item_id=new_item.id)
    return new_item


@app.get("/items/{item_id}", response_model=Item)
async def get_item(
    item_id: int,
    db: AsyncSession = Depends(get_db),
) -> Item:
    """Get item by ID."""
    logger.info("Fetching item", item_id=item_id)

    # In real app, fetch from DB
    if item_id == 1:
        return Item(
            id=1,
            name="Example Item",
            description="An example item",
            price=99.99,
            status="published",
        )

    logger.warning("Item not found", item_id=item_id)
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail="Item not found",
    )


@app.get("/items", response_model=List[Item])
async def list_items(
    skip: int = 0,
    limit: int = Field(default=100, ge=1, le=100),
    db: AsyncSession = Depends(get_db),
) -> List[Item]:
    """List items with pagination."""
    logger.info("Listing items", skip=skip, limit=limit)

    # In real app, fetch from DB with pagination
    return [
        Item(
            id=1,
            name="Example Item",
            description="An example item",
            price=99.99,
            status="published",
        )
    ]


@app.put("/items/{item_id}", response_model=Item)
async def update_item(
    item_id: int,
    item: ItemUpdate,
    db: AsyncSession = Depends(get_db),
) -> Item:
    """Update item."""
    logger.info(
        "Updating item", item_id=item_id, item=item.model_dump(exclude_unset=True)
    )

    # In real app, fetch and update in DB
    existing_item = Item(
        id=item_id,
        name="Example Item",
        description="An example item",
        price=99.99,
        status="published",
    )

    # Update fields
    update_data = item.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(existing_item, field, value)

    logger.info("Item updated", item_id=item_id)
    return existing_item


@app.delete("/items/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_item(
    item_id: int,
    db: AsyncSession = Depends(get_db),
) -> None:
    """Delete item."""
    logger.info("Deleting item", item_id=item_id)

    # In real app, delete from DB
    # await db.delete(item)
    # await db.commit()

    logger.info("Item deleted", item_id=item_id)


# Run with: uvicorn main:app --reload
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info",
    )
